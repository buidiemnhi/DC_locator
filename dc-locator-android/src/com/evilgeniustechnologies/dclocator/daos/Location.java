package com.evilgeniustechnologies.dclocator.daos;

import android.util.Log;

import com.parse.ParseException;
import com.parse.ParseGeoPoint;
import com.parse.ParseObject;
import com.parse.ParseQuery;


import java.util.List;

import de.greenrobot.dao.DaoException;
import com.evilgeniustechnologies.dclocator.local.Datastore;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table LOCATION.
 */
public class Location {

    private String objectId;
    /** Not-null value. */
    private java.util.Date updatedAt;
    private String city;
    private String country;
    private java.util.Date departureDate;
    private String fullAddress;
    private Boolean isPublic;
    private String state;
    private Double checkInLocationLatitude;
    private Double checkInLocationLongitude;
    private String userId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient LocationDao myDao;

    private Member user;
    private String user__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    private static final String TAG = "EGT.Location";
    // KEEP FIELDS END

    public Location() {
    }

    public Location(String objectId) {
        this.objectId = objectId;
    }

    public Location(String objectId, java.util.Date updatedAt, String city, String country, java.util.Date departureDate, String fullAddress, Boolean isPublic, String state, Double checkInLocationLatitude, Double checkInLocationLongitude, String userId) {
        this.objectId = objectId;
        this.updatedAt = updatedAt;
        this.city = city;
        this.country = country;
        this.departureDate = departureDate;
        this.fullAddress = fullAddress;
        this.isPublic = isPublic;
        this.state = state;
        this.checkInLocationLatitude = checkInLocationLatitude;
        this.checkInLocationLongitude = checkInLocationLongitude;
        this.userId = userId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getLocationDao() : null;
    }

    public String getObjectId() {
        return objectId;
    }

    public void setObjectId(String objectId) {
        this.objectId = objectId;
    }

    /** Not-null value. */
    public java.util.Date getUpdatedAt() {
        return updatedAt;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setUpdatedAt(java.util.Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public java.util.Date getDepartureDate() {
        return departureDate;
    }

    public void setDepartureDate(java.util.Date departureDate) {
        this.departureDate = departureDate;
    }

    public String getFullAddress() {
        return fullAddress;
    }

    public void setFullAddress(String fullAddress) {
        this.fullAddress = fullAddress;
    }

    public Boolean getIsPublic() {
        return isPublic;
    }

    public void setIsPublic(Boolean isPublic) {
        this.isPublic = isPublic;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Double getCheckInLocationLatitude() {
        return checkInLocationLatitude;
    }

    public void setCheckInLocationLatitude(Double checkInLocationLatitude) {
        this.checkInLocationLatitude = checkInLocationLatitude;
    }

    public Double getCheckInLocationLongitude() {
        return checkInLocationLongitude;
    }

    public void setCheckInLocationLongitude(Double checkInLocationLongitude) {
        this.checkInLocationLongitude = checkInLocationLongitude;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    /** To-one relationship, resolved on first access. */
    public Member getUser() {
        String __key = this.userId;
        if (user__resolvedKey == null || user__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MemberDao targetDao = daoSession.getMemberDao();
            Member userNew = targetDao.load(__key);
            synchronized (this) {
                user = userNew;
            	user__resolvedKey = __key;
            }
        }
        return user;
    }

    public void setUser(Member user) {
        synchronized (this) {
            this.user = user;
            userId = user == null ? null : user.getObjectId();
            user__resolvedKey = userId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public static void parseLocations(Datastore datastore, ParseQuery<ParseObject> query) throws ParseException {
        List<ParseObject> parseObjects = query.find();
        Log.e(TAG, "locationParseObjects size " + parseObjects.size());
        LocationDao locationDao = datastore.getLocationDao();
        for (ParseObject parseObject : parseObjects) {
            Log.e(TAG, "start parse " + parseObject.getObjectId());
            Location location = parseLocation(locationDao, parseObject);
            Log.e(TAG, "done parse " + location.getObjectId());
        }
    }

    public static Location parseLocation(LocationDao locationDao, ParseObject parseObject) {
        Location location = locationDao.load(parseObject.getObjectId());
        if (location == null) {
            location = new Location();
            location.setObjectId(parseObject.getObjectId());
            location.setUpdatedAt(parseObject.getUpdatedAt());
            location.setCity(parseObject.getString("city"));
            location.setCountry(parseObject.getString("country"));
            location.setDepartureDate(parseObject.getDate("departureDate"));
            location.setFullAddress(parseObject.getString("fullAddress"));
            location.setIsPublic(parseObject.getBoolean("public"));
            location.setState(parseObject.getString("state"));
            ParseObject user = parseObject.getParseObject("user");
            if (user != null) {
                location.setUserId(user.getObjectId());
            }
            ParseGeoPoint parseGeoPoint = parseObject.getParseGeoPoint("checkinLocation");
            if (parseGeoPoint != null) {
                location.setCheckInLocationLatitude(parseGeoPoint.getLatitude());
                location.setCheckInLocationLongitude(parseGeoPoint.getLongitude());
            }
            locationDao.insert(location);
        } else if (location.getUpdatedAt().compareTo(parseObject.getUpdatedAt()) != 0) {
            location.setUpdatedAt(parseObject.getUpdatedAt());
            location.setCity(parseObject.getString("city"));
            location.setCountry(parseObject.getString("country"));
            location.setDepartureDate(parseObject.getDate("departureDate"));
            location.setFullAddress(parseObject.getString("fullAddress"));
            location.setIsPublic(parseObject.getBoolean("public"));
            location.setState(parseObject.getString("state"));
            ParseObject user = parseObject.getParseObject("user");
            if (user != null) {
                location.setUserId(user.getObjectId());
            } else {
                location.setUserId(null);
            }
            ParseGeoPoint parseGeoPoint = parseObject.getParseGeoPoint("checkinLocation");
            if (parseGeoPoint != null) {
                location.setCheckInLocationLatitude(parseGeoPoint.getLatitude());
                location.setCheckInLocationLongitude(parseGeoPoint.getLongitude());
            } else {
                location.setCheckInLocationLatitude(null);
                location.setCheckInLocationLongitude(null);
            }
            locationDao.update(location);
        }
        return location;
    }

    @Override
    public String toString() {
        return "Location{" + '\n' +
                "objectId='" + objectId + '\'' + '\n' +
                ", updatedAt=" + updatedAt + '\n' +
                ", city='" + city + '\'' + '\n' +
                ", country='" + country + '\'' + '\n' +
                ", departureDate=" + departureDate + '\n' +
                ", fullAddress='" + fullAddress + '\'' + '\n' +
                ", isPublic=" + isPublic + '\n' +
                ", state='" + state + '\'' + '\n' +
                ", checkInLocationLatitude=" + checkInLocationLatitude + '\n' +
                ", checkInLocationLongitude=" + checkInLocationLongitude + '\n' +
                ", userId='" + userId + '\'' + '\n' +
                ", user__resolvedKey='" + user__resolvedKey + '\'' + '\n' +
                '}';
    }
    // KEEP METHODS END

}
