package com.evilgeniustechnologies.dclocator.daos;

import android.util.Log;

import com.parse.ParseException;
import com.parse.ParseObject;
import com.parse.ParseQuery;

import java.util.List;

import de.greenrobot.dao.DaoException;
import com.evilgeniustechnologies.dclocator.local.Datastore;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table MESSAGE.
 */
public class Message {

    private String objectId;
    /** Not-null value. */
    private java.util.Date updatedAt;
    private String file;
    private Boolean isPrivate;
    private String content;
    private Integer type;
    private String ownerId;
    private String groupId;
    private String unreadGroupId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient MessageDao myDao;

    private Member owner;
    private String owner__resolvedKey;

    private MessageGroup group;
    private String group__resolvedKey;

    private MessageGroup unreadGroup;
    private String unreadGroup__resolvedKey;

    private List<LikedConnection> likedByConnections;
    private List<ReadConnection> readByConnections;

    // KEEP FIELDS - put your custom fields here
    private static final String TAG = "EGT.Message";
    // KEEP FIELDS END

    public Message() {
    }

    public Message(String objectId) {
        this.objectId = objectId;
    }

    public Message(String objectId, java.util.Date updatedAt, String file, Boolean isPrivate, String content, Integer type, String ownerId, String groupId, String unreadGroupId) {
        this.objectId = objectId;
        this.updatedAt = updatedAt;
        this.file = file;
        this.isPrivate = isPrivate;
        this.content = content;
        this.type = type;
        this.ownerId = ownerId;
        this.groupId = groupId;
        this.unreadGroupId = unreadGroupId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMessageDao() : null;
    }

    public String getObjectId() {
        return objectId;
    }

    public void setObjectId(String objectId) {
        this.objectId = objectId;
    }

    /** Not-null value. */
    public java.util.Date getUpdatedAt() {
        return updatedAt;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setUpdatedAt(java.util.Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public String getFile() {
        return file;
    }

    public void setFile(String file) {
        this.file = file;
    }

    public Boolean getIsPrivate() {
        return isPrivate;
    }

    public void setIsPrivate(Boolean isPrivate) {
        this.isPrivate = isPrivate;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public String getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }

    public String getGroupId() {
        return groupId;
    }

    public void setGroupId(String groupId) {
        this.groupId = groupId;
    }

    public String getUnreadGroupId() {
        return unreadGroupId;
    }

    public void setUnreadGroupId(String unreadGroupId) {
        this.unreadGroupId = unreadGroupId;
    }

    /** To-one relationship, resolved on first access. */
    public Member getOwner() {
        String __key = this.ownerId;
        if (owner__resolvedKey == null || owner__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MemberDao targetDao = daoSession.getMemberDao();
            Member ownerNew = targetDao.load(__key);
            synchronized (this) {
                owner = ownerNew;
            	owner__resolvedKey = __key;
            }
        }
        return owner;
    }

    public void setOwner(Member owner) {
        synchronized (this) {
            this.owner = owner;
            ownerId = owner == null ? null : owner.getObjectId();
            owner__resolvedKey = ownerId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public MessageGroup getGroup() {
        String __key = this.groupId;
        if (group__resolvedKey == null || group__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MessageGroupDao targetDao = daoSession.getMessageGroupDao();
            MessageGroup groupNew = targetDao.load(__key);
            synchronized (this) {
                group = groupNew;
            	group__resolvedKey = __key;
            }
        }
        return group;
    }

    public void setGroup(MessageGroup group) {
        synchronized (this) {
            this.group = group;
            groupId = group == null ? null : group.getObjectId();
            group__resolvedKey = groupId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public MessageGroup getUnreadGroup() {
        String __key = this.unreadGroupId;
        if (unreadGroup__resolvedKey == null || unreadGroup__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MessageGroupDao targetDao = daoSession.getMessageGroupDao();
            MessageGroup unreadGroupNew = targetDao.load(__key);
            synchronized (this) {
                unreadGroup = unreadGroupNew;
            	unreadGroup__resolvedKey = __key;
            }
        }
        return unreadGroup;
    }

    public void setUnreadGroup(MessageGroup unreadGroup) {
        synchronized (this) {
            this.unreadGroup = unreadGroup;
            unreadGroupId = unreadGroup == null ? null : unreadGroup.getObjectId();
            unreadGroup__resolvedKey = unreadGroupId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<LikedConnection> getLikedByConnections() {
        if (likedByConnections == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            LikedConnectionDao targetDao = daoSession.getLikedConnectionDao();
            List<LikedConnection> likedByConnectionsNew = targetDao._queryMessage_LikedByConnections(objectId);
            synchronized (this) {
                if(likedByConnections == null) {
                    likedByConnections = likedByConnectionsNew;
                }
            }
        }
        return likedByConnections;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetLikedByConnections() {
        likedByConnections = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<ReadConnection> getReadByConnections() {
        if (readByConnections == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ReadConnectionDao targetDao = daoSession.getReadConnectionDao();
            List<ReadConnection> readByConnectionsNew = targetDao._queryMessage_ReadByConnections(objectId);
            synchronized (this) {
                if(readByConnections == null) {
                    readByConnections = readByConnectionsNew;
                }
            }
        }
        return readByConnections;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetReadByConnections() {
        readByConnections = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public static void parseUnreadMessages(Datastore datastore, ParseQuery<ParseObject> query) throws ParseException {
        List<ParseObject> parseObjects = query.find();
        Log.e(TAG, "messageParseObjects size " + parseObjects.size());
        MessageDao messageDao = datastore.getMessageDao();
        ReadConnectionDao readConnectionDao = datastore.getReadConnectionDao();
        LikedConnectionDao likedConnectionDao = datastore.getLikedConnectionDao();
        MemberDao memberDao = datastore.getMemberDao();
        for (ParseObject parseObject : parseObjects) {
            Log.e(TAG, parseObject.getObjectId());
            MessageGroup currentGroup = datastore.getGroupDao().load(parseObject.getParseObject("group").getObjectId());
            Message message = parseMessage(currentGroup, memberDao, likedConnectionDao, readConnectionDao, messageDao, parseObject);
            message.setUnreadGroup(currentGroup);
            message.update();
            if (currentGroup.getTempMessageDate() == null || currentGroup.getTempMessageDate().compareTo(message.getUpdatedAt()) < 0) {
                currentGroup.setTempMessageDate(message.getUpdatedAt());
                currentGroup.update();
            }
            if (currentGroup.getTempUnreadMessageDate() == null || currentGroup.getTempUnreadMessageDate().compareTo(message.getUpdatedAt()) < 0) {
                currentGroup.setTempUnreadMessageDate(message.getUpdatedAt());
                currentGroup.update();
            }
        }
    }

    public static void parseMessages(Datastore datastore, ParseQuery<ParseObject> query, String groupId) throws ParseException {
        List<ParseObject> parseObjects = query.find();
        Log.e(TAG, "messageParseObjects size " + parseObjects.size());
        MessageGroup currentGroup = datastore.getGroupDao().load(groupId);
        MessageDao messageDao = datastore.getMessageDao();
        ReadConnectionDao readConnectionDao = datastore.getReadConnectionDao();
        LikedConnectionDao likedConnectionDao = datastore.getLikedConnectionDao();
        MemberDao memberDao = datastore.getMemberDao();
        for (ParseObject parseObject : parseObjects) {
            Log.e(TAG, "start parse " + parseObject.getObjectId());
            Message message = parseMessage(currentGroup, memberDao, likedConnectionDao, readConnectionDao, messageDao, parseObject);
            Log.e(TAG, "done parse " + message.getObjectId());
            if (currentGroup.getTempMessageDate() == null || currentGroup.getTempMessageDate().compareTo(message.getUpdatedAt()) < 0) {
                currentGroup.setTempMessageDate(message.getUpdatedAt());
                currentGroup.update();
            }
        }
    }

    public static com.evilgeniustechnologies.dclocator.daos.Message parseMessage(MessageGroup group, MemberDao memberDao, LikedConnectionDao likedConnectionDao, ReadConnectionDao readConnectionDao, MessageDao messageDao, ParseObject parseObject) {
        Log.e(TAG, "check if exists");
        com.evilgeniustechnologies.dclocator.daos.Message message = messageDao.load(parseObject.getObjectId());
        Log.e(TAG, "is exist? " + (message != null));
        if (message == null) {
            message = new com.evilgeniustechnologies.dclocator.daos.Message();
            Log.e(TAG, "objectId");
            message.setObjectId(parseObject.getObjectId());
            Log.e(TAG, "updatedAt");
            message.setUpdatedAt(parseObject.getUpdatedAt());
//            ParseFile file = parseObject.getParseFile("file");
//            if (file != null) {
//                message.setFile(file.getUrl());
//            }
            Log.e(TAG, "isPrivate");
            message.setIsPrivate(parseObject.getBoolean("isPrivate"));
            Log.e(TAG, "message");
            message.setContent(parseObject.getString("message"));
            Log.e(TAG, "type");
            message.setType(parseObject.getInt("type"));
            Log.e(TAG, "groupId");
            message.setGroupId(group.getObjectId());
            Log.e(TAG, "owner");
            ParseObject owner = parseObject.getParseObject("objectIDOfClassUser");
            if (owner != null) {
                message.setOwnerId(owner.getObjectId());
//                Member.parseMember(memberDao, owner);
            }
            Log.e(TAG, "read_by");
            List<ParseObject> readBy = parseObject.getList("read_by");
            if (readBy != null && !readBy.isEmpty()) {
                for (ParseObject user : readBy) {
                    ReadConnection connection = new ReadConnection();
                    connection.setReadMessage(message);
                    connection.setReadUserId(user.getObjectId());
                    readConnectionDao.insert(connection);
                }
            }
            Log.e(TAG, "liked_by");
            List<ParseObject> likedBy = parseObject.getList("liked_by");
            if (likedBy != null && !likedBy.isEmpty()) {
                for (ParseObject user : likedBy) {
                    LikedConnection connection = new LikedConnection();
                    connection.setLikedMessage(message);
                    connection.setLikedUserId(user.getObjectId());
                    likedConnectionDao.insert(connection);
                }
            }
            Log.e(TAG, "insert");
            messageDao.insert(message);
        }
//        else if (message.getUpdatedAt().compareTo(parseObject.getUpdatedAt()) != 0) {
//            Log.e(TAG, "here");
//            message.setUpdatedAt(parseObject.getUpdatedAt());
////            ParseFile file = parseObject.getParseFile("file");
////            if (file != null) {
////                message.setFile(file.getUrl());
////            }
//            message.setIsPrivate(parseObject.getBoolean("isPrivate"));
//            message.setContent(parseObject.getString("message"));
//            message.setType(parseObject.getInt("type"));
//            message.setGroupId(group.getObjectId());
//            ParseObject owner = parseObject.getParseObject("objectIDOfClassUser");
//            if (owner != null) {
//                message.setOwnerId(owner.getObjectId());
//                Member.parseMember(memberDao, owner);
//            } else {
//                message.setOwnerId(null);
//            }
//            List<ParseObject> readBy = parseObject.getList("read_by");
//            if (readBy != null && !readBy.isEmpty()) {
//                for (ParseObject user : readBy) {
//                    ReadConnection connection = new ReadConnection();
//                    connection.setReadMessage(message);
//                    connection.setReadUserId(user.getObjectId());
//                    readConnectionDao.insert(connection);
//                }
//            } else {
//                if (message.getReadByConnections() != null && !message.getReadByConnections().isEmpty()) {
//                    readConnectionDao.deleteInTx(message.getReadByConnections());
//                }
//            }
//            List<ParseObject> likedBy = parseObject.getList("liked_by");
//            if (likedBy != null && !likedBy.isEmpty()) {
//                for (ParseObject user : likedBy) {
//                    LikedConnection connection = new LikedConnection();
//                    connection.setLikedMessage(message);
//                    connection.setLikedUserId(user.getObjectId());
//                    likedConnectionDao.insert(connection);
//                }
//            } else {
//                if (message.getLikedByConnections() != null && !message.getLikedByConnections().isEmpty()) {
//                    likedConnectionDao.deleteInTx(message.getLikedByConnections());
//                }
//            }
//            messageDao.update(message);
//        }
        Log.e(TAG, "return");
        return message;
    }

    @Override
    public String toString() {
        return "Message{" + '\n' +
                "objectId='" + objectId + '\'' + '\n' +
                ", updatedAt=" + updatedAt + '\n' +
                ", file='" + file + '\'' + '\n' +
                ", isPrivate=" + isPrivate + '\n' +
                ", content='" + content + '\'' + '\n' +
                ", type=" + type + '\n' +
                ", ownerId='" + ownerId + '\'' + '\n' +
                ", groupId='" + groupId + '\'' + '\n' +
                ", unreadGroupId='" + unreadGroupId + '\'' + '\n' +
                ", owner__resolvedKey='" + owner__resolvedKey + '\'' + '\n' +
                ", group__resolvedKey='" + group__resolvedKey + '\'' + '\n' +
                ", unreadGroup__resolvedKey='" + unreadGroup__resolvedKey + '\'' + '\n' +
                ", likedByConnections=" + getLikedByConnections().size() + '\n' +
                ", readByConnections=" + getReadByConnections().size() + '\n' +
                '}';
    }
    // KEEP METHODS END

}
